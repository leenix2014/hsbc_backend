package org.hsbc.util;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

/**
 * Utility for algorithm PBKDF2 to sign password
 * @author Leen Li
 */
public class PBKDF2Util {
    //Constants
    private static final String PBKDF2_ALGORITHM = "PBKDF2WithHmacSHA1";
    private static final int HASH_BIT_SIZE = 128 * 4;
    private static final int PBKDF2_ITERATIONS = 1000;

    /**
     * validate if the password is right
     * @param password Cleartext password when login, need a secure channel between api and consumer
     * @param salt pre-saved salt in storage
     * @param dbPassword pre-saved encryptedPassword in storage
     * @return whether password is correct.
     */
    public static boolean checkPassword(String password, String salt, String dbPassword) {
        String encryptedPassword = encryptPassword(password, salt);
        return encryptedPassword.equals(dbPassword);
    }

    /**
     * Encrypt password with slow hash PBKDF2. Slow hash for Brute-force attack, salt for Lookup table attacks and Rainbow attack
     * @param password Cleartext password when registered, need a secure channel between api and consumer
     * @param salt Random string, generated by server
     * @return hash signature
     */
    public static String encryptPassword(String password, String salt) {
        if(password == null){// user input password may be null
            password = "";
        }
        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt.getBytes(), PBKDF2_ITERATIONS, HASH_BIT_SIZE);
        SecretKeyFactory f;
        byte[] result;
        try {
            f = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);
            result = f.generateSecret(spec).getEncoded();
        } catch (Exception e) {
            throw new RuntimeException(e);// should not reach here
        }
        return toHex(result);
    }

    /**
     * Translate bytes into hex string
     * @param bytes bytes
     * @return hex string
     */
    private static String toHex(byte[] bytes) {
        BigInteger bi = new BigInteger(1, bytes);// 1 for positive
        String hex = bi.toString(16);// radix is 16
        int paddingLength = (bytes.length * 2) - hex.length();
        if (paddingLength > 0)
            return String.format("%0" + paddingLength + "d", 0) + hex;
        else
            return hex;
    }

    //Some tests in main
//    public static void main(String[] args) {
////        String password = null;
//        String password = "Abcd1234";
//        String salt = StringUtil.randomString(8);
//        String dbPassword = encryptPassword(password, salt);
//        System.out.println(dbPassword);
////        password = "Abcd123";
//        System.out.println(checkPassword(password, salt, dbPassword));
//    }
}